export const data = [
  {
    title: "Components",
    content: [
      {
        p: "Приложения React состоят из компонентов. Компоненты позволяют разбить интерфейс на независимые части, про которые легко думать в отдельности. Их можно складывать вместе и использовать несколько раз. Компонент может быть маленьким, как кнопка, или большим, как целая страница.",
      },
      {
        p: "Компоненты — это независимые и многократно используемые фрагменты кода, функции. Они служат той же цели, что и функции JavaScript, но работают изолированно и возвращают JSX",
      },
      {
        h: "Функциональные и классовые компоненты",
      },
      { p: "Проще всего объявить React-компонент как функцию" },
      {
        c: `function Welcome(props) {
    return <h1> Привет, {props.name} </h1>;
}`,
      },
      { p: "С точки зрения React, эти два компонента эквивалентны." },
      {
        err: "Компонент класса должен включать extends React.Component оператор. Этот оператор создает наследование для React.Component и предоставляет вашему компоненту доступ к функциям React.Component.",
      },
      {
        h: "Композиция компонентов",
      },
      {
        p: "Компоненты могут ссылаться на другие компоненты в возвращённом ими дереве. Это позволяет использовать одну и ту же абстракцию — компоненты — на любом уровне нашего приложения. Неважно, пишем ли мы кнопку, форму или целый экран: все они, как правило, представляют собой компоненты в React-приложениях.",
      },
      {
        p: "Например, компонент App может отрендерить компонент Welcome несколько раз:",
      },
      {
        c: `function Welcome(props) {
return <h1>Привет, {props.name}</h1>;
}
  
function App() {
    return (
        <div>
            <Welcome name= "Алиса" />
            <Welcome name= "Базилио" />
            <Welcome name= "Буратино" />
        </div>
    );
}`,
      },
    ],
    path: "components",
  },
  {
    title: "Props",
    content: [
      {
        p: "В React свойства props представляют механизм передачи данных в компонент. Синтаксически Props представляет коллекцию значений, которые ассоциированы с компонентом. Эти значения позволяют создавать динамические компоненты, которые не зависят от жестко закодированных статических данных.",
      },
      {
        h: "Что такое props?",
      },
      {
        p: "- Props — это объект, содержащий данные, которые передаются в компонент из его родителя.Props похожи на параметры функций: они предоставляют компонентам необходимую информацию для корректной работы.",
      },
      {
        h: "Функциональный подход:",
      },
      {
        c: `function Person(props) {
  return <div>
            <p>Имя: {props.name}</p>
            <p>Возраст: {props.age}</p>
    </div>;
}`,
      },
      {
        p: "Props передаются в компоненты так же, как атрибуты в HTML-элементы.",
      },
      {
        h: "Передача данных через JSX",
      },
      {
        p: "Синтаксис прост: данные указываются как атрибуты JSX:",
      },
      {
        c: `function Welcome(props) {
  return <h1>Welcome, {props.userName}!</h1>;
}

<Welcome userName={"Pavel"} />;`,
      },
      {
        h: "Пример с числом и булевыми значениями",
      },
      {
        c: `function UserStatus(props) {
  return (
    <div>
      <p>User ID: {props.id}</p>
      <p>Status: {props.isActive ? 'Active' : 'Inactive'}</p>
    </div>
  );
}

<UserStatus id={123} isActive={true} />;`,
      },
      {
        err: "Пропсы являются неизменяемыми (immutable), их нельзя изменять напрямую.",
      },
      {
        c: `function Example(props) {
  props.name = "Ivan"; // Нельзя!
  return <p>{props.name}</p>;
}`,
      },
      {
        h: "Props поддерживают сложные типы данных",
      },
      {
        c: `function TodoList(props) {
  return (
    <ul>
      {props.todos.map((todo, index) => (
        <li key={index}>{todo}</li>
      ))}
    </ul>
  );
}

<TodoList todos={["Learn React", "Build a project", "Get a job"]} />;`,
      },
    ],
    path: "props",
  },
  {
    title: "State",
    content: [
      {
        p: "State (состояние) в React — это место, где компонент хранит свои динамические данные. Это как записная книжка, которую компонент использует для хранения текущего состояния и его изменения.",
      },
      {
        h: "Чем отличается state от props?",
      },
      {
        p: "Props передаются компоненту снаружи, от родителя и неизменные.State управляется внутри компонента и изменяется",
      },
      {
        h: "Hook useState",
      },
      {
        p: "В функциональных компонентах для работы с state используется хук useState.",
      },
      {
        p: "Он возвращает массив из двух элементов: state: текущее значение состояния, setState: функцию для его обновления, а принимает initialState: начальное значение состояния. Может быть примитивным типом данных, объектом или функцией.",
      },
      {
        c: ` import React, { useState } from 'react';

const [state, setState] = useState(initialState);
import React, { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Current count: {count}</p>
      <button onClick={() => setCount((prevCount) => prevCount + 1)}>Increase</button>
    </div>
  );
}`,
      },
      {
        err: "State должен быть неизменяемым напрямую. Если ты попытаешься изменить его напрямую, React не поймёт, что нужно обновить интерфейс",
      },
      {
        c: `// Неправильно
state.count = 10;`,
      },
      {
        p: "Вместо этого используй setState, чтобы сообщить React об изменении:",
      },
      {
        c: `setState(newValue);`,
      },
      {
        p: "Обновление state происходит асинхронно. Если нужно обновить состояние на основе его текущего значения, используй функцию:",
      },
      { c: `setCount((prevCount) => prevCount + 1);` },
      {
        err: "Когда мы вызываем setState, React не обновляет состояние и не рендерит компонент немедленно. Вместо этого он помещает обновление в очередь. После этого React применяет все обновления состояния за один раз перед следующим рендером компонента.",
      },
      {
        err: "Асинхронное поведение сеттеров в React позволяет: oбъединять несколько обновлений состояния в одно, что уменьшает количество рендеров и улучшает производительность; гарантировать, что компоненты рендерятся с наиболее актуальным состоянием.",
      },
      {
        p: "Когда state обновляется, React автоматически перерисовывает компонент. Это делает работу с интерфейсом более удобной, но может привести к лишним обновлениям, если state изменяется слишком часто.",
      },
    ],
    path: "state",
  },
  {
    title: "Lifecycle",
    content: [
      {
        p: "В React у компонентов есть свои шаги, которые они проходят, когда создаются, обновляются или удаляются. Эти шаги называются жизненным циклом компонента.",
      },
      {
        p: "Например, у компонента есть специальные моменты, когда он: рождается,обновляется, умирает.",
      },
      {
        err: "В предыдущих версиях React использовался классовый компонент и его методы жизненного цикла. Однако, с появлением React Hooks в React 16.8, функциональные компоненты также получили новые методы жизненного цикла с использованием хуков.",
      },
      { h: "Основные этапы жизненного цикла компонента" },
      {
        p: "1. Монтирование (Mounting)",
      },
      { p: "Это этап, когда компонент создаётся и вставляется в DOM." },
      {
        p: "Основные методы:",
      },
      {
        p: "constructor: Здесь происходит инициализация состояния и привязка методов.",
      },
      {
        c: `constructor(props) {
  super(props);
  this.state = { data: null };
}`,
      },
      {
        p: "render: Метод, который возвращает JSX-разметку. Вызывается при создании и обновлении компонента.",
      },
      {
        p: "componentDidMount: Вызывается один раз после того, как компонент вставлен в DOM. Отличное место для запросов к серверу, подписки на события или установки таймеров.",
      },
      {
        c: `componentDidMount() {
  fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => this.setState({ data }));
}`,
      },
      {
        p: "2. Обновление (Updating)",
      },
      {
        p: "Компонент может обновляться, когда изменяются его props или state.",
      },
      {
        p: "Основные методы:",
      },
      {
        p: "shouldComponentUpdate: Позволяет контролировать, следует ли перерисовывать компонент. Можно использовать для оптимизации производительности.",
      },
      {
        p: "render: Вызывается снова для обновления отображения.",
      },
      {
        p: "componentDidUpdate: Вызывается сразу после обновления компонента. Здесь можно, например, реагировать на изменение данных, выполнять дополнительные запросы или работать с изменённым DOM.",
      },
      {
        c: `componentDidUpdate(prevProps, prevState) {
  if (prevState.data !== this.state.data) {
    console.log('Данные обновились!');
  }
}`,
      },
      {
        p: "3. Размонтирование (Unmounting)",
      },
    ],
    path: "lifecycle",
  },
];
