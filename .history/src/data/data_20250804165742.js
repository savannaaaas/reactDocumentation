export const data = [
  {
    title: "Components",
    content: [
      {
        p: "Приложения React состоят из компонентов. Компоненты позволяют разбить интерфейс на независимые части, про которые легко думать в отдельности. Их можно складывать вместе и использовать несколько раз. Компонент может быть маленьким, как кнопка, или большим, как целая страница.",
      },
      {
        p: "Компоненты — это независимые и многократно используемые фрагменты кода, функции. Они служат той же цели, что и функции JavaScript, но работают изолированно и возвращают JSX",
      },
      {
        h: "Функциональные и классовые компоненты",
      },
      { p: "Проще всего объявить React-компонент как функцию" },
      {
        c: `function Welcome(props) {
    return <h1> Привет, {props.name} </h1>;
}`,
      },
      { p: "С точки зрения React, эти два компонента эквивалентны." },
      {
        err: "Компонент класса должен включать extends React.Component оператор. Этот оператор создает наследование для React.Component и предоставляет вашему компоненту доступ к функциям React.Component.",
      },
      {
        h: "Композиция компонентов",
      },
      {
        p: "Компоненты могут ссылаться на другие компоненты в возвращённом ими дереве. Это позволяет использовать одну и ту же абстракцию — компоненты — на любом уровне нашего приложения. Неважно, пишем ли мы кнопку, форму или целый экран: все они, как правило, представляют собой компоненты в React-приложениях.",
      },
      {
        p: "Например, компонент App может отрендерить компонент Welcome несколько раз:",
      },
      {
        c: `function Welcome(props) {
return <h1>Привет, {props.name}</h1>;
}
  
function App() {
    return (
        <div>
            <Welcome name= "Алиса" />
            <Welcome name= "Базилио" />
            <Welcome name= "Буратино" />
        </div>
    );
}`,
      },
    ],
    path: "components",
  },
  {
    title: "Props",
    content: [
      {
        p: "В React свойства props представляют механизм передачи данных в компонент. Синтаксически Props представляет коллекцию значений, которые ассоциированы с компонентом. Эти значения позволяют создавать динамические компоненты, которые не зависят от жестко закодированных статических данных.",
      },
      {
        h: "Что такое props?",
      },
      {
        p: "- Props — это объект, содержащий данные, которые передаются в компонент из его родителя.Props похожи на параметры функций: они предоставляют компонентам необходимую информацию для корректной работы.",
      },
      {
        h: "Функциональный подход:",
      },
      {
        c: `function Person(props) {
  return <div>
            <p>Имя: {props.name}</p>
            <p>Возраст: {props.age}</p>
    </div>;
}`,
      },
      {
        p: "Props передаются в компоненты так же, как атрибуты в HTML-элементы.",
      },
      {
        h: "Передача данных через JSX",
      },
      {
        p: "Синтаксис прост: данные указываются как атрибуты JSX:",
      },
      {
        c: `function Welcome(props) {
  return <h1>Welcome, {props.userName}!</h1>;
}

<Welcome userName={"Pavel"} />;`,
      },
      {
        h: "Пример с числом и булевыми значениями",
      },
      {
        c: `function UserStatus(props) {
  return (
    <div>
      <p>User ID: {props.id}</p>
      <p>Status: {props.isActive ? 'Active' : 'Inactive'}</p>
    </div>
  );
}

<UserStatus id={123} isActive={true} />;`,
      },
      {
        err: "Пропсы являются неизменяемыми (immutable), их нельзя изменять напрямую.",
      },
      {
        c: `function Example(props) {
  props.name = "Ivan"; // Нельзя!
  return <p>{props.name}</p>;
}`,
      },
      {
        h: "Props поддерживают сложные типы данных",
      },
      {
        c: `function TodoList(props) {
  return (
    <ul>
      {props.todos.map((todo, index) => (
        <li key={index}>{todo}</li>
      ))}
    </ul>
  );
}

<TodoList todos={["Learn React", "Build a project", "Get a job"]} />;`,
      },
    ],
    path: "props",
  },
  {
    title: "State",
    content: [
      {
        p: "State (состояние) в React — это место, где компонент хранит свои динамические данные. Это как записная книжка, которую компонент использует для хранения текущего состояния и его изменения.",
      },
      {
        h: "Чем отличается state от props?",
      },
      {
        p: "Props передаются компоненту снаружи, от родителя и неизменные.State управляется внутри компонента и изменяется",
      },
      {
        h: "useState",
      },
      {
        p: "В функциональных компонентах для работы с state используется хук useState.",
      },
      {
        p: "Он возвращает массив из двух элементов: state: текущее значение состояния, setState: функцию для его обновления, а принимает initialState: начальное значение состояния. Может быть примитивным типом данных, объектом или функцией.",
      },
      {
        c: ` import React, { useState } from 'react';

const [state, setState] = useState(initialState);
import React, { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Current count: {count}</p>
      <button onClick={() => setCount((prevCount) => prevCount + 1)}>Increase</button>
    </div>
  );
}`,
      },
      {
        err: "State должен быть неизменяемым напрямую. Если ты попытаешься изменить его напрямую, React не поймёт, что нужно обновить интерфейс",
      },
      {
        c: `// Неправильно
state.count = 10;`,
      },
      {
        p: "Вместо этого используй setState, чтобы сообщить React об изменении:",
      },
      {
        c: `setState(newValue);`,
      },
      {
        p: "Обновление state происходит асинхронно. Если нужно обновить состояние на основе его текущего значения, используй функцию:",
      },
      { c: `setCount((prevCount) => prevCount + 1);` },
      {
        err: "Когда мы вызываем setState, React не обновляет состояние и не рендерит компонент немедленно. Вместо этого он помещает обновление в очередь. После этого React применяет все обновления состояния за один раз перед следующим рендером компонента.",
      },
      {
        err: "Асинхронное поведение сеттеров в React позволяет: oбъединять несколько обновлений состояния в одно, что уменьшает количество рендеров и улучшает производительность; гарантировать, что компоненты рендерятся с наиболее актуальным состоянием.",
      },
      {
        p: "Когда state обновляется, React автоматически перерисовывает компонент. Это делает работу с интерфейсом более удобной, но может привести к лишним обновлениям, если state изменяется слишком часто.",
      },
    ],
    path: "state",
  },
  {
    title: "Lifecycle",
    content: [
      {
        p: "В React у компонентов есть свои шаги, которые они проходят, когда создаются, обновляются или удаляются. Эти шаги называются жизненным циклом компонента.",
      },
      {
        p: "Например, у компонента есть специальные моменты, когда он: рождается,обновляется, умирает.",
      },
      {
        err: "В предыдущих версиях React использовался классовый компонент и его методы жизненного цикла. Однако, с появлением React Hooks в React 16.8, функциональные компоненты также получили новые методы жизненного цикла с использованием хуков.",
      },
      { h: "Основные этапы жизненного цикла компонента" },
      {
        p: "1. Монтирование (Mounting)",
      },
      { p: "Это этап, когда компонент создаётся и вставляется в DOM." },
      {
        b: "Основные методы:",
      },
      {
        p: "constructor: Здесь происходит инициализация состояния и привязка методов.",
      },
      {
        c: `constructor(props) {
  super(props);
  this.state = { data: null };
}`,
      },
      {
        p: "- render: метод, который возвращает JSX-разметку. Вызывается при создании и обновлении компонента.",
      },
      {
        p: "- componentDidMount: вызывается один раз после того, как компонент вставлен в DOM. Отличное место для запросов к серверу, подписки на события или установки таймеров.",
      },
      {
        c: `componentDidMount() {
  fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => this.setState({ data }));
}`,
      },
      {
        p: "2. Обновление (Updating)",
      },
      {
        p: "Компонент может обновляться, когда изменяются его props или state.",
      },
      {
        b: "Основные методы:",
      },
      {
        p: "- shouldComponentUpdate: позволяет контролировать, следует ли перерисовывать компонент. Можно использовать для оптимизации производительности.",
      },
      {
        p: "- render: вызывается снова для обновления отображения.",
      },
      {
        p: "- componentDidUpdate: вызывается сразу после обновления компонента. Здесь можно, например, реагировать на изменение данных, выполнять дополнительные запросы или работать с изменённым DOM.",
      },
      {
        c: `componentDidUpdate(prevProps, prevState) {
  if (prevState.data !== this.state.data) {
    console.log('Данные обновились!');
  }
}`,
      },
      {
        p: "3. Размонтирование (Unmounting)",
      },
      {
        p: "Это момент, когда компонент удаляется из DOM.",
      },
      {
        b: "Основной метод:",
      },
      {
        p: "componentWillUnmount: Здесь происходит очистка: отписка от событий, остановка таймеров, отмена сетевых запросов. Это помогает избежать утечек памяти.",
      },
      {
        c: `componentWillUnmount() {
  // Отписываемся от событий, очищаем таймеры и т.д.
  console.log('Компонент удалён');
}`,
      },
      { p: "4. Обработка ошибок (Error Handling)" },
      {
        p: "Если во время работы компонента происходит ошибка, можно её перехватить и обработать.",
      },
      {
        b: "Методы:",
      },
      {
        p: "- static getDerivedStateFromError(error): Позволяет обновить состояние, чтобы отобразить запасной UI при возникновении ошибки.",
      },
      {
        p: "- componentDidCatch(error, info): Позволяет записать информацию об ошибке или отправить её на сервер для дальнейшего анализа.",
      },
      {
        p: "Сегодня большинство разработчиков используют функциональные компоненты, а не классовые. Вместо методов жизненного цикла в классах здесь применяется хук useEffect.",
      },
      {
        err: "useEffect - это хук в React, предназначенный для работы с методами жизненного цикла в функциональных компонентах. По сути вот хук заменяет основные методы жизненного цикла.",
      },
      {
        p: "1. Первый параметр: Функция, которая должна выполниться при монтировании компонента и при каждом обновлении.",
      },
      {
        p: "2. Второй параметр: Массив зависимостей определяет, на что конкретно должен реагировать useEffect. Если массив пуст, useEffect выполняется только при монтировании и размонтировании. Если в массиве указаны определенные значения, то useEffect будет выполняться только тогда, когда эти значения изменяются.",
      },
      {
        c: `// Отработает как componentDidMount
useEffect(() => { console.log("componentDidMount") }, []) 

// Отработает как componentDidUpdate 
useEffect(() => { console.log("componentDidUpdate") }, [dependency]) 

// Отработает как componentDidMount и componentDidUpdate
useEffect(() => { console.log("componentDidMount и componentDidUpdate") }) 

 // Отработает как componentWillUnmount
useEffect(() => {
  return () => console.log('componentWillUnmount')
}, [])`,
      },
      {
        err: "Таким образом, при первом рендере компонента useEffect также будет вызван, даже если он имеет зависимость и при этом первоначальное значение зависимости не изменилось. Это не является ошибкой, а предполагаемое поведение хуков.",
      },
    ],
    path: "lifecycle",
  },
  {
    title: "Events",
    content: [
      {
        p: "В React события (events) являются важной частью взаимодействия с пользователем. Они позволяют обрабатывать действия пользователя, такие как клики, наведение, отправка формы и другие. ",
      },
      {
        b: "Вот пять наиболее часто используемых событий в React и примеры их применения:",
      },
      {
        b: "1. onClick (Клик):",
      },
      {
        p: "Событие onClick возникает при клике на элементе. Это одно из наиболее распространенных событий в React.",
      },
      {
        c: `const handleClick = () => {
  console.log('Кликнули!');
}

const MyComponent = () => {
  return (
    <button onClick={handleClick}>Нажми меня</button>
  );
}`,
      },
      {
        b: "2 onChange (Изменение):",
      },
      {
        p: "Событие onChange возникает при изменении значения элемента формы, такого как текстовое поле (input), флажок (checkbox) или выбор элемента списка (radio).",
      },
      {
        c: `const handleChange = (event) => {
  console.log('Изменилось значение:', event.target.value);
}

const MyComponent = () => {
  return (
    <input type="text" onChange={handleChange} />
    или
    <input type="text" onChange={event => handleChange(event)} />
  );
}`,
      },
      {
        err: "В React, параметр event в callback-функции представляет объект события, который генерируется при каждом событии. event.target.value содержит текущее значение input элемента.",
      },
      { b: "3. onSubmit (Отправка формы):" },
      {
        p: "Событие onSubmit возникает при отправке формы. Оно позволяет выполнить действия, связанные с отправкой данных формы на сервер.",
      },
      {
        c: `const handleSubmit = (event) => {
  event.preventDefault();
  console.log('Форма отправлена!');
}

const MyComponent = () => {
  return (
    <form onSubmit={handleSubmit}>
      {/* поля формы */}
      <button type="submit">Отправить</button>
    </form>
  );`,
      },
      {
        b: "4. onMouseOver (Наведение курсора):",
      },
      {
        p: "Событие onMouseOver возникает, когда курсор наводится на элемент. Оно может использоваться для отображения дополнительной информации или изменения состояния компонента при наведении.",
      },
      {
        c: `const handleMouseOver = () => {
  console.log('Курсор наведен!');
}

const MyComponent = () => {
  return (
    <div onMouseOver={handleMouseOver}>Наведите курсор на меня</div>
  );
}`,
      },
      {
        b: "5. onKeyDown (Нажатие клавиши):",
      },
      {
        p: "Событие onKeyDown возникает при нажатии клавиши на клавиатуре. Оно позволяет реагировать на определенные комбинации клавиш или выполнять действия на основе нажатых клавиш.",
      },
      {
        c: `const handleKeyDown = (event) => {
  console.log('Нажата клавиша:', event.key);
}

const MyComponent = () => {
  return (
    <input type="text" onKeyDown={handleKeyDown} />
  );
}`,
      },
    ],
    path: "events",
  },
  {
    title: "Key",
    content: [
      {
        p: "key — это уникальный идентификатор, который React использует для определения, какие элементы списка изменились, добавились или удалились. Без key React перерисовывает элементы списка неэффективно, что может привести к неожиданному поведению и падению производительности.",
      },
      {
        err: "Если не указать ключи, в консоли увидим сообщение: Warning: Each child in an array or iterator should have a unique “key” prop. ",
      },
      {
        h: "Основные правила использования key:",
      },
      {
        b: "1. Используй уникальные значения:",
      },
      {
        p: "key должен быть уникальным для каждого элемента. Лучше всего использовать стабильные идентификаторы, такие как ID из данных. Если нет ID используй библиотеку uuid:",
      },
      {
        c: `const users = [{ id: 1, name: 'Анна' }, { id: 2, name: 'Павел' }];
return users.map((user) => <div key={user.id}>{user.name}</div>)`,
      },
      {
        b: "2. Не используй индекс массива:",
      },
      {
        p: "Использование индекса как key может вызвать баги, особенно при изменении порядка элементов в списке.",
      },
      {
        c: `//Неправильно
        items.map((item, index) => <div key={index}>{item}</div>);`,
      },
      {
        b: "3. Сохраняй стабильность ключей:",
      },
      {
        p: "Убедись, что значение key не меняется между рендерами, иначе React будет считать элемент новым и удалять старый.",
      },
      { b: "Пример нестабильного key:" },
      {
        p: "Представим, что у нас есть компонент, отображающий список задач. Мы создаём key на основе библиотеки uuid (что нестабильно)",
      },
      {
        c: `function TaskList({ tasks }) {
  return (
    <ul>
      {tasks.map((task) => (
        <li key={uuidv1()}>{task.name}</li>
      ))}
    </ul>
  );
}`,
      },
      {
        b: "Что здесь пойдёт не так:",
      },
      {
        p: "Каждый раз при рендере `uuidv1()` генерирует новое значение. React считает, что каждый элемент списка полностью новый, даже если данные не изменились.Это приведёт к тому, что React удалит старые DOM-элементы и создаст новые, что вызовет потерю состояния (например, фокуса на элементах) и сниженную производительность.",
      },
      {
        err: "Без key механизм reconciliation сверяет компоненты попарно между текущим и новым VDOM. Из-за этого может происходить большое количество лишних перерисовок интерфейса, что замедляет работу приложения.",
      },
      {
        p: "Добавляя key, мы помогаем механизму reconciliation тем, что с key он сверяет не попарно, а ищет компоненты с тем же key (тег / имя компонента при этом учитывается) — это уменьшает количество перерисовок интерфейса. Обновлены/добавлены будут только те элементы, которые были изменены/не встречались в предыдущем дереве. ",
      },
    ],
    path: "key",
  },
  {
    title: "Refs",
    content: [
      {
        p: "Refs в React позволяют получить доступ к DOM-элементам или компонентам напрямую. Это своего рода «обходной путь», который даёт тебе возможность взаимодействовать с элементами вне обычного React-потока данных.",
      },
      {
        h: "Зачем нужны Refs?",
      },
      {
        p: "Refs полезны в следующих случаях:",
      },
      {
        b: "1. Доступ к DOM-элементам:",
      },
      {
        c: `const inputRef = useRef();

function focusInput() {
  inputRef.current.focus();
}

return (
  <div>
    <input ref={inputRef} type="text" />
    <button onClick={focusInput}>Фокус</button>
  </div>
);`,
      },
      {
        b: "2. Работа с внешними библиотеками:",
      },
      {
        p: "Например, для интеграции с библиотеками, которые манипулируют DOM напрямую (например, Chart.js или Three.js).",
      },
      {
        h: "Почему не стоит злоупотреблять Refs?",
      },
      { b: "1. Обход React-философии:" },
      {
        p: "Использование Refs идёт вразрез с основными принципами React (однонаправленный поток данных). Если злоупотреблять ими, это приведёт к созданию сложного и запутанного кода.",
      },
      { b: "2. Трудности тестирования и поддержки:" },
      {
        p: "Логика, завязанная на Refs, делает код менее предсказуемым и сложным в отладке.",
      },
      {
        b: "3. Проблемы с производительностью:",
      },
      {
        p: "Обращение к DOM через Refs может негативно сказаться на производительности, особенно в сложных приложениях.",
      },
      {
        p: "Лучше стараться использовать state и props для управления данными и поведением, а Refs применять только в исключительных случаях.",
      },
      {
        h: "Что такое forwardRef?",
      },
      {
        p: "forwardRef — это инструмент, который позволяет передавать Ref в дочерний компонент. Это полезно, когда тебе нужно получить доступ к DOM-элементу, который находится внутри кастомного компонента.",
      },
      {
        c: `const CustomInput = forwardRef((props, ref) => {
  return <input ref={ref} {...props} />;
});

function App() {
  const inputRef = useRef();

  return (
    <div>
      <CustomInput ref={inputRef} />
      <button onClick={() => inputRef.current.focus()}>Фокус</button>
    </div>
  );
}`,
      },
      {
        b: "Использование ref для хранения значений между рендерами",
      },
      {
        p: "useRef в React можно использовать не только для работы с DOM, но и для хранения данных между рендерами без их повторного вызова.",
      },
      {
        b: "Пример: сохранение предыдущего значения стейта",
      },
      {
        c: `import { useRef, useState, useEffect } from "react";

function PreviousStateExample() {
  const [count, setCount] = useState(0);
  const prevCount = useRef(null);

  useEffect(() => {
    prevCount.current = count; // Запоминаем предыдущее значение после рендера
  }, [count]);

  return (
    <div>
      <p>Текущее значение: {count}</p>
      <p>Предыдущее значение: {prevCount.current}</p>
      <button onClick={() => setCount(count => count + 1)}>Увеличить</button>
    </div>
  );
}`,
      },
      {
        h: "Когда использовать Refs?",
      },
      {
        b: "1. Фокусировка или управление DOM:",
      },
      {
        p: "Например, фокус на инпуте после загрузки страницы.",
      },
      {
        b: "2. Реализация пользовательских анимаций:",
      },
      {
        p: "Доступ к элементу для прямого управления его стилями.",
      },
      { b: "3. Интеграция с внешними библиотеками:" },
      { p: "Например, инициализация стороннего плагина для DOM." },
    ],
    path: "refs",
  },
  {
    title: "VirtualDOM",
    content: [
      {
        p: "Виртуальный DOM (VDOM) — это концепция программирования, при которой идеальное, или «виртуальное», представление пользовательского интерфейса хранится в памяти и синхронизируется с «реальным» DOM с помощью библиотеки, например ReactDOM. Этот процесс называется согласованием .",
      },
      {
        p: "Поскольку «виртуальный DOM» — это скорее шаблон, чем конкретная технология, люди иногда используют его в разных значениях. В мире React термин «виртуальный DOM» обычно ассоциируется с элементами React, поскольку они представляют собой объекты пользовательского интерфейса. Однако React также использует внутренние объекты, называемые «волокнами», для хранения дополнительной информации о дереве компонентов. Их также можно рассматривать как часть реализации «виртуального DOM» в React.",
      },
      { h: "Почему это важно?" },
      { b: "1. Эффективность" },
      {
        p: "React обновляет только изменённые элементы, снижая нагрузку на браузер и ускоряя рендер.",
      },
      {
        b: "2. Удобство",
      },
      {
        p: "Ты работаешь с компонентами, а React сам оптимизирует обновления.",
      },
      {
        b: "Переносимость",
      },
      {
        p: "React одинаково работает во всех браузерах, избавляя от проблем совместимости.",
      },
      {
        h: "Reconciliation",
      },
      {
        p: "Reconciliation – это процесс, при котором React сравнивает предыдущее и новое состояние компонента, определяя минимальный набор изменений, который нужно внести в пользовательский интерфейс.",
      },
      {
        err: "Reconciliation делает React молниеносным, потому что он не перерисовывает весь интерфейс, а только изменённые элементы. ",
      },
      {
        h: "Fiber",
      },
      {
        p: "Когда React только появился, он был быстрым, но с ростом проектов старый механизм обновлений начал тормозить.Представь, что у тебя огромное приложение, где обновляются и список товаров, и форма ввода, и анимация. Если обновлять всё сразу – интерфейс может замереть на мгновение, создавая неприятные лаги.Чтобы решить эту проблему, React представил Fiber – новый движок рендеринга, который сделал обновления плавными, предсказуемыми и суперэффективными.",
      },
      {
        err: "Fiber – это не замена Reconciliation, а его улучшенная версия. Они работают вместе.",
      },
    ],
    path: "virtual-dom",
  },
  {
    title: "Fragment",
    content: [
      {
        p: "Fragment в React — это вспомогательный компонент, который позволяет оборачивать несколько дочерних элементов без добавления лишнего элемента в DOM. Это полезно, если тебе нужно вернуть несколько элементов, но ты не хочешь создавать дополнительный <div> или другой контейнер.",
      },
      { h: "Зачем нужен Fragment?" },
      {
        p: "1. Избегает лишних обёрток в DOM: Дополнительные контейнеры могут усложнять стилизацию и негативно влиять на производительность.",
      },
      {
        p: "2. Улучшает читаемость JSX: Код становится проще и понятнее.",
      },
      {
        h: "Как использовать Fragment?",
      },
      {
        c: `function App() {
  return (
    <React.Fragment>
      <h1>Hello Child Component</h1>
	    <h1>Hello Child Component</h1>
    </React.Fragment>
  );
}`,
      },
      {
        c: `import React, { Fragment } from 'react';

//так хорошо
const ChildComponent = () => <>
    <h1>Hello Child Component</h1>
    <h1>Hello Child Component</h1>
</>

// так нельзя. Будет ошибка
const ChildComponent = () => < id="child" >
    <h1>Hello Child Component</h1>
    <h1>Hello Child Component</h1>
</>`,
      },
      {
        err: "Если вы хотите передать key данные фрагменту, использовать этот синтаксис нельзя <>...</>. Вам придётся явно импортировать данные Fragment из фрагмента 'react'и отрисовывать их <Fragment key={yourKey}>...</Fragment>.",
      },
      {
        err: "React не сбрасывает состояние при переходе от рендеринга <> <Child /> </> к [<Child />] или обратно, а также при переходе от рендеринга <> <Child /> </> к <Child /> и обратно. Это работает только на один уровень вглубь: например, переход от <> <> <Child /> </> </> к <Child /> сбрасывает состояние.",
      },
    ],
    path: "fragment",
  },
  {
    title: "React.memo",
    content: [
      {
        p: "React.memo — это функция высшего порядка (HOC), которая используется для оптимизации функциональных компонентов. Она предотвращает ненужные повторные рендеры, если пропсы компонента не изменились.",
      },
      { h: "Что принимает и что возвращает React.memo?" },
      { b: "Принимает (React.memo(Component, compareFunction?)):" },
      {
        p: "1. Компонент (обязательный параметр) – функциональный компонент, который нужно мемоизировать.",
      },
      {
        p: "2. Функцию сравнения пропсов (необязательный параметр) – кастомная функция для сравнения старых и новых пропсов.",
      },
      {
        b: "Возвращает:",
      },
      {
        p: "Новый мемоизированный компонент, который ререндерится только при изменении пропсов.",
      },
      {
        p: "React обычно перерисовывает компонент при каждом перерисовывании его родителя. С помощью React.memo можно создать компонент, который React не будет перерисовывать при повторном перерисовывании его родителя, пока его новые свойства совпадают со старыми. Такой компонент называется мемоизированным .Чтобы запомнить компонент, заключите его в оболочку memoи используйте возвращаемое им значение вместо исходного компонента:",
      },
      {
        c: `const Greeting = memo(function Greeting({ name }) {
  return <h1>Hello, {name}!</h1>;
});

export default Greeting;`,
      },
      {
        p: "Компонент React всегда должен иметь чистую логику рендеринга. Это означает, что он должен возвращать тот же результат, если его свойства, состояние и контекст не изменились. Используя memo, вы сообщаете React, что ваш компонент соответствует этому требованию, поэтому React не нужно выполнять повторный рендеринг, пока его свойства не изменились. Даже при использовании memo, ваш компонент будет перерисовываться при изменении его собственного состояния или используемого им контекста.",
      },
      {
        err: "Даже если компонент мемоизирован, он всё равно будет перерисовываться при изменении своего состояния. Мемоизация касается только свойств, передаваемых компоненту от его родителя.",
      },
      {
        p: "При использовании memo, ваш компонент перерисовывается каждый раз, когда какое-либо свойство не является поверхностно равным тому, что было ранее. Это означает, что React сравнивает каждое свойство в вашем компоненте с его предыдущим значением, используя Object.isсравнение. Обратите внимание , Object.is(3, 3)что true, Object.is({}, {})но false. Чтобы получить максимальную отдачу от memo, минимизируйте количество изменений свойств.",
      },
      {
        err: "React сравнивает старые и новые свойства по принципу поверхностного равенства: то есть проверяет, является ли каждое новое свойство равным по ссылке старому.",
      },
    ],
  },
  {
    title: "useEffect",
    content: [
      {
        p: "useEffect - это хук в React, предназначенный для работы с методами жизненного цикла в функциональных компонентах. ",
      },
      {
        b: "Первый параметр: Функция, которая должна выполниться при монтировании компонента и при каждом обновлении.",
      },
      {
        b: "Второй параметр: Массив зависимостей определяет, на что конкретно должен реагировать useEffect. Если массив пуст, useEffect выполняется только при монтировании и размонтировании. Если в массиве указаны определенные значения, то useEffect будет выполняться только тогда, когда эти значения изменяются.",
      },
      {
        c: `// Отработает как componentDidMount
useEffect(() => { console.log("componentDidMount") }, []) 

// Отработает как componentDidUpdate
useEffect(() => { console.log("componentDidUpdate") }, [dependency]) 

// Отработает как componentDidMount и componentDidUpdate
useEffect(() => { console.log("componentDidMount и componentDidUpdate") }) 

 // Отработает как componentWillUnmount
useEffect(() => {
  return () => console.log('componentWillUnmount')
}, [])`,
      },
      {
        b: "1. Mounting (Монтирование):",
      },
      {
        p: "useEffect(() => {}, []): Заменяет componentDidMount(). Выполняет побочные эффекты только один раз после монтирования. Передавая пустой массив зависимостей [], можно сделать хук useEffect аналогомcomponentDidMount.",
      },
      {
        b: "2. Updating (Обновление):",
      },
      {
        p: "useEffect(() => {}, [dependency]): Заменяет componentDidUpdate(). Позволяет указать зависимость для выполнения функции только при изменении определенных props или state.  ",
      },
      {
        p: "useEffect(() => {}): Выполняет функцию после каждого рендеринга компонента. Отрабатывает как  componentDidMount() и componentDidUpdate()",
      },
      {
        c: `// Отработает как componentDidUpdate
useEffect(() => { console.log("componentDidUpdate") }, [dependency]) `,
      },
      {
        b: "3. Unmounting (Размонтирование):",
      },
      {
        p: "useEffect(() => () => {}): Заменяет componentWillUnmount(). Выполняет очистку и отписку от побочных эффектов при размонтировании (удалении из DOM) компонента.",
      },
      {
        c: `import React, { useState, useEffect } from 'react';

const Example = () => {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log('Компонент был монтирован');
    return () => {
      console.log('Компонент будет размонтирован');
    };
  }, []); // Пустой массив зависимостей и возвращает функцию, 
					// а значит выполнится только при монтировании и размонтировании

  return (
    <div>
      <p>Счетчик: {count}</p>
      <button onClick={() => setCount((count) => count + 1)}>Увеличить</button>
    </div>
  );
}

export default Example;`,
      },
      {
        p: "В этом примере useEffect выполняется при монтировании компонента и возвращает функцию, которая будет выполнена при размонтировании. Так как второй параметр useEffect - это пустой массив зависимостей [], он не будет срабатывать при обновлении состояний.",
      },
      {
        c: `import React, { useState, useEffect } from "react";

const Example = () => {
  const [count, setCount] = useState(0);
  const [message, setMessage] = useState("");

  useEffect(() => {
    setMessage("Счетчик изменен на:", count);
  }, [count]); // Зависимость [count] - выполнится при изменении состояния count

  return (
    <div>
      <p>{message}</p>
      <p>Счетчик: {count}</p>
      <button onClick={() => setCount((count) => count + 1)}>Увеличить</button>
    </div>
  );
};

export default Example;`,
      },
      {
        p: "В этом примере useEffect выполняется при изменении значения count, так как count является зависимостью, переданной в массиве [count]. Когда count изменяется, useEffect обновляет состояние message, отображая новое сообщение о счетчике.",
      },
      {
        p:"В React хуки, такие как useEffect, выполняются при каждом рендере компонента, включая первый рендер после монтирования. Это особенность работы хуков, и они 
не повторяют точно поведение метода жизненного цикла componentDidMount из классовых компонентов."
      },
      {
        err: "При первом рендере компонента useEffect также будет вызван, даже если он имеет зависимость и при этом первоначальное значение зависимости не изменилось. Это не является ошибкой, а предполагаемое поведение хуков.",
      },
    ],
  },
];
